#!/usr/bin/env python3
import os
import sys
import time
import zipfile
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed

WORKDIR = Path.home() / "theZoo_simple"
OUTDIR  = WORKDIR / "extracted"
ZIP_FILE = WORKDIR / "theZoo.zip"
ZIP_URL  = "https://codeload.github.com/ytisf/theZoo/zip/refs/heads/master"
PASS = "infected"
PROMPT_SECS = 300
DEFAULT_WORKERS = max(2, os.cpu_count() or 2)
FLATTEN = True 

def run(cmd):
    return subprocess.run(cmd, check=True)

def ensure_repo():
    WORKDIR.mkdir(parents=True, exist_ok=True)
    if not ZIP_FILE.exists():
        print("[1/4] Baixando repositório (wget)…")
        run(["wget", "-q", "-O", str(ZIP_FILE), ZIP_URL])
    else:
        print("[1/4] ZIP já existe, pulando download.")

    repo_root = None
    for p in WORKDIR.iterdir():
        if p.is_dir() and p.name.lower().startswith("thezoo"):
            repo_root = p
            break
    if repo_root is None:
        print("[2/4] Extraindo repositório (unzip)…")
        run(["unzip", "-q", "-o", str(ZIP_FILE), "-d", str(WORKDIR)])
        for p in WORKDIR.iterdir():
            if p.is_dir() and p.name.lower().startswith("thezoo"):
                repo_root = p
                break
    if repo_root is None:
        sys.exit("Erro: não encontrei a pasta do repositório após extrair.")
    return repo_root

def find_binaries(repo_root: Path) -> Path:
    for name in ("binaries", "Binaries"):
        d = repo_root / "malware" / name
        if d.exists():
            return d
    sys.exit("Erro: não encontrei malware/binaries no repositório.")

def list_families(bin_dir: Path):
    fams = sorted([p for p in bin_dir.iterdir() if p.is_dir()], key=lambda p: p.name.lower())
    if not fams:
        sys.exit("Nenhuma família encontrada.")
    print(f"\n[3/4] Famílias em {bin_dir}:\n")
    for i, fam in enumerate(fams):
        print(f"[{i}] {fam.name}")
    return fams

def prompt_choice(fams):
    print("\n[4/4] Escolha índices separados por vírgula (ex: 0,2,5).")
    print(f"Se não responder em {PROMPT_SECS//60} minutos, vou extrair TODAS.")
    print(f"(timeout: {PROMPT_SECS}s)")

    try:
        import select
        start = time.time()
        choice = ""
        while True:
            rlist, _, _ = select.select([sys.stdin], [], [], 1)
            if rlist:
                choice = sys.stdin.readline().strip()
                break
            if time.time() - start > PROMPT_SECS:
                break
    except Exception:
        try:
            choice = input("> ")
        except EOFError:
            choice = ""

    if not choice:
        print("\n⚠️ Sem resposta — extraindo TODAS.")
        return fams

    picked = []
    for chunk in choice.split(","):
        chunk = chunk.strip()
        if chunk.isdigit():
            i = int(chunk)
            if 0 <= i < len(fams):
                picked.append(fams[i])
    if not picked:
        print("Nenhum índice válido — extraindo TODAS.")
        return fams
    return picked

def find_archives(folder: Path):
    EXTS = (".zip", ".7z", ".rar")
    return [p for p in folder.rglob("*") if p.is_file() and p.suffix.lower() in EXTS]

def extract_one(src: Path, fam_out: Path) -> tuple[Path, bool, str]:
    dest = fam_out if FLATTEN else fam_out / src.stem
    dest.mkdir(parents=True, exist_ok=True)

    cmd = [
        "7z", "x",
        f"-p{PASS}", "-y",
        "-mmt=on",
        "-bso0", "-bsp0",
        f"-o{str(dest)}",
        str(src)
    ]
    try:
        subprocess.run(cmd, check=True)
        return (src, True, "ok")
    except subprocess.CalledProcessError as e:
        return (src, False, f"7z falhou (code {e.returncode})")
    except FileNotFoundError:
        return (src, False, "7z não encontrado (instale p7zip)")

def extract_selected(families, workers=DEFAULT_WORKERS):
    OUTDIR.mkdir(parents=True, exist_ok=True)
    tasks = []
    for fam in families:
        fam_archives = find_archives(fam)
        fam_out = OUTDIR / fam.name
        fam_out.mkdir(parents=True, exist_ok=True)
        if not fam_archives:
            print(f"– {fam.name}: nenhum arquivo compactado encontrado.")
            continue
        for a in fam_archives:
            tasks.append((a, fam_out))

    if not tasks:
        print("Nada para extrair.")
        return

    print(f"\nExtraindo {len(tasks)} arquivo(s)…")
    ok, fail = 0, 0
    with ThreadPoolExecutor(max_workers=DEFAULT_WORKERS) as ex:
        futs = [ex.submit(extract_one, a, d) for (a, d) in tasks]
        for f in as_completed(futs):
            src, success, msg = f.result()
            if success: ok += 1
            else: fail += 1
            print(f"[{('OK' if success else 'ERRO'):>4}] {src.name} -> {msg}")

    print(f"\nPrimeira fase concluída. Sucesso: {ok} | Falhas: {fail}")

def final_inline_extract(selected_fams):
    """Passo final: extrai QUALQUER .zip/.7z/.rar que tenha ficado
    dentro de OUTDIR/<Família> diretamente ali (modo 'flatten'), como no seu exemplo."""
    print("\nFase final: extração inline dentro das pastas selecionadas…")
    total, ok, fail = 0, 0, 0
    for fam in selected_fams:
        fam_out = OUTDIR / fam.name
        if not fam_out.exists():
            continue
        # apenas nível atual da pasta da família (sem recursão profunda)
        archives = [p for p in fam_out.iterdir()
                    if p.is_file() and p.suffix.lower() in (".zip", ".7z", ".rar")]
        if not archives:
            continue
        print(f"→ {fam_out} : {len(archives)} arquivo(s) a extrair")
        for src in archives:
            total += 1
            cmd = [
                "7z", "x",
                f"-p{PASS}", "-y",
                "-mmt=on",
                "-bso0", "-bsp0",
                f"-o{str(fam_out)}",
                str(src)
            ]
            try:
                subprocess.run(cmd, check=True)
                ok += 1
                print(f"[ OK ] {src.name}")
            except subprocess.CalledProcessError as e:
                fail += 1
                print(f"[ERRO] {src.name} -> 7z code {e.returncode}")
            except FileNotFoundError:
                fail += 1
                print(f"[ERRO] {src.name} -> 7z não encontrado")
    print(f"\nFase final: processados {total}, sucesso {ok}, falhas {fail}")
    print(f"Saída: {OUTDIR}")

def main():
    repo_root = ensure_repo()
    bin_dir = find_binaries(repo_root)
    fams = list_families(bin_dir)
    selected = prompt_choice(fams)
    extract_selected(selected)
    final_inline_extract(selected)

if __name__ == "__main__":
    main()
